{"componentChunkName":"component---src-templates-tags-template-js","path":"/tags/2024/","result":{"data":{"allMarkdownRemark":{"totalCount":8,"nodes":[{"fields":{"slug":"/blog/clean-code-chapter-12/"},"frontmatter":{"date":"February 14, 2024","description":"창발적 설계로 깔끔한 코드를 구현하자","tags":["cleancode","2024"],"title":"Clean-Code Chapter12"},"excerpt":"…"},{"fields":{"slug":"/blog/clean-code-chapter-11/"},"frontmatter":{"date":"February 14, 2024","description":"이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.","tags":["cleancode","2024"],"title":"Clean-Code Chapter11"},"excerpt":"Intro…"},{"fields":{"slug":"/blog/refactoring-chapter-9/"},"frontmatter":{"date":"February 14, 2024","description":"프로그램 실행중에 객체 분류코드가 변한다면 상태/전략 패턴으로 치환하고 위임을 사용합니다.","tags":["refactoring","2024"],"title":"Refactoring Chapter 9"},"excerpt":"리팩토링 분류 코드를 상태/전략 패턴로 치환 As-Is 상태패턴 \r\nLogger 클래스에 int로 선언되어 있는 상태값들을 State 객체로 치환해 준 후 각 상태에 따른 하위 클래스를 상속받아 구현합니다. To-Be 더 나아가기 개발자는 Logger…"},{"fields":{"slug":"/blog/refactoring-chapter-8/"},"frontmatter":{"date":"February 07, 2024","description":"분류코드마다 객체동작을 바꾸고 싶다면 하위클래스를 이용한 다형적 메서드를 만듭니다.","tags":["refactoring","2024"],"title":"Refactoring Chapter 8"},"excerpt":"리팩토링 분류 코드를 하위 클래스로 치환 단순히 객체를 식별하는 것뿐만 아니라 분류 코드 종류에 따라 객첵 다른 동작을 한다면 클래스로 치환하는 것 만으로 쉽게 해결할 수 없습니다. As-Is Shape 클래스는 도형을 나타냅니다. getName…"},{"fields":{"slug":"/blog/refactoring-chapter-7/"},"frontmatter":{"date":"February 07, 2024","description":"객체 종류를 나타내는 분류코드를 int 같은 기본타입으로 표현하면 타입판별이 제대로 안됩니다. 분류코드를 나타내는 클래스를 만들고 타입판별이 되게해봅시다.","tags":["refactoring","2024"],"title":"Refactoring Chapter 7"},"excerpt":"리팩토링 분류 코드를 클래스로 치환 As-Is Item 이라는 객체가 있습니다 item의 타입을 static 변수로 생성하여 객체 생성 시 넣어줍니다. 이렇게 타입을 int 로 설계할 경우 이렇게도 객체를 생성할 수 있습니다.…"},{"fields":{"slug":"/blog/observer-pattern/"},"frontmatter":{"date":"January 30, 2024","description":"여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대하여 알리는 구독 메커니즘을 정의할 수 있도록 합니다.","tags":["design pattern","observer pattenr","2024"],"title":"Observer Pattern"},"excerpt":"Observer Pattern  Problem…"},{"fields":{"slug":"/blog/마이크로 프론트엔드/"},"frontmatter":{"date":"January 30, 2024","description":"프론트엔드 아키텍쳐의 발전 과정과 마이크로 프론트엔드에 대한 설명","tags":["frontend","프론트엔드","마이크로 프론트엔드","2024"],"title":"마이크로 프론트엔드"},"excerpt":"1. 마이크로 서비스란? 일반적으로 복잡한 문제를 해결할 때 가장 효율적인 방식은 문제는 작게 나누어 작은 문제를 해결하는 방식입니다. 데이터 단위로 작게 나누어 작은 문제를 하나씩 해결을 해나가는게 마이크로 서비스의 개념입니다.…"},{"fields":{"slug":"/blog/HTTP 1.1/"},"frontmatter":{"date":"January 30, 2024","description":"HTTP에 대한 설명 및 사용되는 속성 정리","tags":["frontend","프론트엔드","HTTP","2024"],"title":"HTTP 구조에 대해"},"excerpt":"HTTP 클라이언트 / 서버 모델을 따르는 프로토콜로 TCP/IP 프로토콜 위에서 동작합니다. 이때 웹에서 필요한 모든 종류의 데이터 HTML, 이미지, 오디오 등을 전송합니다. 1. HTTP 1.1 구조에 대해 1.1 request 구조 HTTP…"}]}},"pageContext":{"tag":"2024"}},"staticQueryHashes":["2714594843","3159585216"]}